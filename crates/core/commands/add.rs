use crate::app::{self, resolve_entry_resolver, take_first_resolvable, user_select_resolvable};

use seb::ast::{Biblio, BiblioResolver, Entry};

use clap::{AppSettings, Subcommand};
use eyre::{eyre, Context};
use log::{info, trace};

#[derive(Subcommand)]
#[allow(clippy::module_name_repetitions)]
pub enum AddCommands {
    /// Search for reference by doi
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Doi {
        /// The doi to search for
        doi: String,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
    /// Search for entry by IETF RFC number
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Ietf {
        /// The RFC number to search for
        rfc_number: usize,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
    /// Search for reference by ISBN
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Isbn {
        /// The ISBN to search for
        isbn: String,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
}

type DynError = Box<dyn std::error::Error>;

impl AddCommands {
    pub(super) fn execute(self, biblio: &mut Biblio, interact: bool) -> Result<String, DynError> {
        let entry = if interact {
            self.interact_execute(biblio)?
        } else {
            self.detached_execute(biblio)?
        };

        let cite = entry.cite().to_owned();
        biblio.insert(entry);
        info!("Entry with cite '{cite}' added to bibliography");
        Ok(cite)
    }

    fn interact_execute(self, biblio: &mut Biblio) -> eyre::Result<Entry> {
        let bib = self.search_entries(biblio)?;
        let mut entry = user_select_resolvable(bib)?.or_else(resolve_entry_resolver)?;
        self.set_cite(&mut entry);
        Ok(entry)
    }

    fn detached_execute(self, biblio: &Biblio) -> Result<Entry, DynError> {
        let mut entry = self.take_entry(biblio)?;
        self.set_cite(&mut entry);
        Ok(entry)
    }

    fn take_entry(&self, biblio: &Biblio) -> Result<Entry, DynError> {
        let bib = self.search_entries(biblio)?;
        take_first_resolvable(bib).map_err(Into::into)
    }

    fn search_entries(&self, biblio: &Biblio) -> eyre::Result<Result<Biblio, BiblioResolver>> {
        match self {
            AddCommands::Doi { doi, .. } => {
                dbg!("doi subcommand called with value of '{}", &doi);
                trace!("Checking current bibliography for possible duplicate doi..");
                app::check_entry_field_duplication(biblio, "doi", doi)?;
                trace!("No duplicate found!");
                seb::entries_by_doi(doi).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
            AddCommands::Ietf { rfc_number, .. } => {
                dbg!("ietf subcommand called with value of '{}", &rfc_number);
                trace!("Checking current bibliography for possible duplicate RFC number..");
                app::check_entry_field_duplication(biblio, "number", &rfc_number.to_string())?;
                trace!("No duplicate found!");
                seb::entries_by_rfc(*rfc_number).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
            AddCommands::Isbn { isbn, .. } => {
                dbg!("isbn subcommand called with value of '{}", &isbn);
                trace!("Checking current bibliography for possible duplicate ISBN.");
                app::check_entry_field_duplication(biblio, "isbn", isbn)?;
                trace!("No duplicate found!");
                seb::entries_by_isbn(isbn).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
        }
    }

    fn set_cite(self, entry: &mut Entry) {
        match self {
            AddCommands::Doi {
                cite: Some(cite), ..
            }
            | AddCommands::Ietf {
                cite: Some(cite), ..
            }
            | AddCommands::Isbn {
                cite: Some(cite), ..
            } => entry.set_cite(cite),
            _ => {}
        }
    }
}
