#![deny(
    clippy::all,
    clippy::pedantic,
    clippy::perf,
    clippy::style,
    clippy::missing_safety_doc,
    clippy::missing_const_for_fn
)]
#![allow(clippy::as_conversions, clippy::mod_module_files)]

use std::{error, path::PathBuf, process};

mod app;
mod file;

use clap::{AppSettings, Parser, Subcommand};
use eyre::eyre;
use log::{info, trace};
use seb::{
    ast::{Biblio, Entry},
    format::{BibTex, Reader, Writer},
};

fn main() {
    if let Err(err) = try_main() {
        dbg!("{:?}", &err);
        eprintln!("{}", err);
        process::exit(2);
    }
}

fn try_main() -> Result<(), Box<dyn error::Error>> {
    let Cli {
        command,
        file,
        verbosity,
        cite,
        quiet,
        confirm,
    } = Cli::parse();

    setup_errlog(verbosity as usize, quiet)?;

    let mut file = file::open_or_create_format_file::<BibTex>(file)?;
    let mut biblio = file.read_ast()?;

    let mut entries = command.execute(&biblio)?;

    if entries.is_empty() {
        return Err(eyre!("No entries found!").into());
    }

    let mut entry = if confirm {
        info!("Confirm flag set - picking the first entry found..");
        entries.remove(0)
    } else {
        app::user_select(entries)?
    };

    dbg!("Entry found: {:?}", &entry);

    if let Some(cite) = cite {
        info!("Overriding cite key value with '{}'", cite);
        entry.set_cite(cite);
    }
    let cite_key = entry.cite().to_owned();

    biblio.insert(entry);

    trace!("Adding selected entry into bibliography");
    file.write_ast(biblio)?;
    trace!("Done!");
    println!("Entry added to bibliography with cite key:\n{}", cite_key);
    Ok(())
}

fn setup_errlog(verbosity: usize, quiet: bool) -> Result<(), Box<dyn error::Error>> {
    // if quiet then ignore verbosity but still show errors
    let verbosity = if quiet {
        dbg!("quiet flag used but dbg! and error will still be shown");
        1
    } else {
        verbosity + 2
    };

    stderrlog::new().verbosity(verbosity).init()?;
    Ok(())
}

#[derive(Parser)]
#[clap(name = "seb")]
#[clap(about = "Search and edit bibliographic entries to a supported format file in the terminal")]
#[clap(version, author)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,

    /// The name of the file
    #[clap(short, long, parse(from_os_str))]
    file: Option<PathBuf>,

    /// How chatty the program is when performing commands
    ///
    /// The number of times this flag is used will increase how chatty
    /// the program is.
    #[clap(short, long, parse(from_occurrences))]
    verbosity: u8,

    /// The cite key of the new entry
    ///
    /// This will override any citation key either present or generated by seb.
    #[clap(long)]
    cite: Option<String>,

    /// Prevents the program from writing to stdout, errors will still be printed to stderr.
    #[clap(short, long)]
    quiet: bool,

    /// Auto selects the first bibliographic entry found on search.
    ///
    /// This will select the very first option in this list of found entries on a search,
    /// for searches by doi, isbn and other unique identifiers this should lead to predicatable
    /// results (depends on the API).
    #[clap(long)]
    confirm: bool,
}

#[derive(Subcommand)]
#[non_exhaustive]
enum Commands {
    /// Search for reference by doi
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Doi {
        /// The doi to search for
        doi: String,
    },
    /// Search for reference by ISBN
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Isbn {
        /// The ISBN to search for
        isbn: String,
    },
}

impl Commands {
    fn execute(self, biblio: &Biblio) -> eyre::Result<Vec<Entry>> {
        match &self {
            Commands::Doi { doi } => {
                dbg!("doi subcommand called with value of '{}'", doi);
                trace!("Checking current bibliography for possible duplicate doi..");
                app::check_entry_field_duplication(biblio, "doi", doi)?;
                trace!("No duplicate found!");
                seb::entries_by_doi(doi)
            }
            Commands::Isbn { isbn } => {
                dbg!("isbn subcommand called with value of '{}'", isbn);
                trace!("Checking current bibliography for possible duplicate isbn..");
                app::check_entry_field_duplication(biblio, "isbn", isbn)?;
                trace!("No duplicate found!");
                seb::entries_by_isbn(isbn)
            }
        }
    }
}
