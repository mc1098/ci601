use crate::{
    app::{self, resolve_entry_resolver, take_first_resolvable, user_select_resolvable},
    interact::{user_resolve_entry, user_select_map},
};

use seb::ast::{Biblio, BiblioResolver, Entry};

use clap::Subcommand;
use eyre::{eyre, Context};
use log::{debug, info, trace};

#[derive(Subcommand)]
#[allow(clippy::module_name_repetitions)]
pub enum AddCommands {
    /// Search for reference by doi
    #[clap(arg_required_else_help = true)]
    Doi {
        /// The doi to search for
        doi: String,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
    /// Search for entry by IETF RFC number
    #[clap(arg_required_else_help = true)]
    Ietf {
        /// The RFC number to search for
        rfc_number: usize,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
    /// Search for reference by ISBN
    #[clap(arg_required_else_help = true)]
    Isbn {
        /// The ISBN to search for
        isbn: String,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
    /// Search for entry using the title
    #[clap(arg_required_else_help = true)]
    Title {
        /// The title to search for
        title: String,

        /// The cite key of the new entry
        ///
        /// This will override any citation key either present or generated by seb.
        #[clap(long)]
        cite: Option<String>,
    },
}

type DynError = Box<dyn std::error::Error>;

impl AddCommands {
    pub(super) fn execute(
        self,
        biblio: &mut Biblio,
        mut interact: bool,
    ) -> Result<String, DynError> {
        // take a copy of interact bool and use it to determine if the first resolvable item should
        // be resolved
        let resolve = interact;
        let search_results = self.search_entries(biblio, &mut interact)?;

        let mut entry = if interact {
            user_select_resolvable(search_results)?.or_else(resolve_entry_resolver)?
        } else {
            match take_first_resolvable(search_results) {
                Err(mut resolver) if resolve => {
                    user_resolve_entry(&mut resolver)?;
                    resolver.resolve()?
                }
                e => e?,
            }
        };

        self.set_cite(&mut entry);

        let cite = entry.cite().to_owned();
        biblio.insert(entry);
        info!("Entry with cite '{cite}' added to bibliography");
        Ok(cite)
    }

    fn search_entries(
        &self,
        biblio: &Biblio,
        interact: &mut bool,
    ) -> eyre::Result<Result<Biblio, BiblioResolver>> {
        match self {
            AddCommands::Doi { doi, .. } => {
                debug!("doi subcommand called with a value of '{doi}'");
                app::check_entry_field_duplication(biblio, "doi", doi)?;
                seb::entries_by_doi(doi).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
            AddCommands::Ietf { rfc_number, .. } => {
                debug!("ietf subcommand called with value of '{}'", &rfc_number);
                app::check_entry_field_duplication(biblio, "number", &rfc_number.to_string())?;
                seb::entries_by_rfc(*rfc_number).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
            AddCommands::Isbn { isbn, .. } => {
                debug!("isbn subcommand called with value of '{isbn}'");
                app::check_entry_field_duplication(biblio, "isbn", isbn)?;
                seb::entries_by_isbn(isbn).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
            AddCommands::Title { title, .. } => {
                debug!("title subcommand called with value of '{title}'");
                // We don't check duplication with title because it is unlikely to be a complete
                // title or to match fully with an existing entry.
                // Instead we will perform the search for entry stubs (doi, title) and once
                // one is selected then perform the duplication check on the doi.
                trace!("Searching parts of an entry by title..");
                let mut entry_stubs = seb::entry_stubs_by_title(title)?;

                let index = if *interact {
                    user_select_map("Confirm entry", &entry_stubs, |(_, title)| title.clone())?
                } else {
                    trace!("Interact mode not enabled - taking first entry part");
                    0
                };

                *interact = false;

                let doi = entry_stubs.remove(index).0;
                app::check_entry_field_duplication(biblio, "doi", &doi)?;
                seb::entries_by_doi(&doi).wrap_err_with(|| eyre!("Cannot find the entry"))
            }
        }
    }

    fn set_cite(self, entry: &mut Entry) {
        match self {
            AddCommands::Doi {
                cite: Some(cite), ..
            }
            | AddCommands::Ietf {
                cite: Some(cite), ..
            }
            | AddCommands::Isbn {
                cite: Some(cite), ..
            } => entry.set_cite(cite),
            _ => {}
        }
    }
}
